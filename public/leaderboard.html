<!DOCTYPE html>
<html>
<head>
  <title>Leaderboard</title>
  <style>
    body { 
      font-family: sans-serif; 
      max-width: 800px; 
      margin: 2rem auto; 
    }
    select { 
      margin-bottom: 1rem; 
      padding: 0.5rem; 
      font-size: 1rem; 
    }
    table { 
      width: 100%; 
      border-collapse: collapse; 
      margin-top: 1rem; 
    }
    th, td { padding: 0.5rem; border: 1px solid #ccc; text-align: left; }
    th {
      background: #f0f0f0;
      cursor: pointer;
      user-select: none;
    }
    th.sorted-asc::after  { content: " ‚ñ≤"; }
    th.sorted-desc::after { content: " ‚ñº"; }

    tbody.fade {
      animation: fadeIn 0.5s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Highlight top row */
    tr.highlight {
      background-color: #ffeaa7;
      animation: highlightFlash 1s ease;
    }
    @keyframes highlightFlash {
      0%   { background-color: #ffeaa7; }
      50%  { background-color: #fff; }
      100% { background-color: #ffeaa7; }
    }
  </style>
</head>
<body>
  <h1>üèÜ Leaderboard</h1>

  <label for="modeSelector">Select Mode:</label>
  <select id="modeSelector">
    <option value="10">10 Words</option>
    <option value="25" selected>25 Words</option>
    <option value="50">50 Words</option>
    <option value="100">100 Words</option>
  </select>

  <p id="modeLabel" style="font-style: italic; margin-top: 0.5rem;">(25 Words Leaderboard)</p>

  <table>
    <thead>
      <tr>
        <th data-key="rank">Rank</th>
        <th data-key="username">Name</th>
        <th data-key="wpm">WPM</th>
        <th data-key="accuracy">Accuracy</th>
      </tr>
    </thead>
    <tbody id="leaderboardBody"></tbody>
  </table>

  <p><a href="/type">Back to Game</a></p>

  <script>
    let leaderboardData = [];
    let sortKey = 'wpm';
    let sortAsc = false;
    let selectedNumWords = 25; // default

    async function fetchData() {
      const res = await fetch(`/api/leaderboard?numWords=${selectedNumWords}`);
      const data = await res.json();
      leaderboardData = data.map((row, i) => ({ ...row, _initialIndex: i }));
      renderTable();
    }

    function renderTable() {
      let displayData;

      if (sortKey === 'rank') {
        displayData = [...leaderboardData].sort((a, b) =>
          sortAsc
            ? a._initialIndex - b._initialIndex
            : b._initialIndex - a._initialIndex
        );
      } else {
        displayData = [...leaderboardData].sort((a, b) => {
          let aVal, bVal;
          if (sortKey === 'accuracy') {
            aVal = (a.accuracy ?? 0);
            bVal = (b.accuracy ?? 0);
            aVal = (aVal <= 1) ? aVal * 100 : aVal;
            bVal = (bVal <= 1) ? bVal * 100 : bVal;
          } else {
            aVal = (a[sortKey] ?? 0);
            bVal = (b[sortKey] ?? 0);
          }
          return (aVal < bVal ? -1 : aVal > bVal ? 1 : 0) * (sortAsc ? 1 : -1);
        });
      }

      const tbody = document.getElementById('leaderboardBody');
      tbody.classList.remove('fade'); // reset animation
      void tbody.offsetWidth; // force reflow for animation
      tbody.innerHTML = '';

      displayData.forEach((row, i) => {
        const rank = i + 1;
        const wpmDisplay = typeof row.wpm === 'number'
          ? row.wpm.toFixed(1)
          : '‚Äì';
        let accDisplay;
        if (typeof row.accuracy === 'number') {
          const rawAcc = row.accuracy <= 1
            ? row.accuracy * 100
            : row.accuracy;
          accDisplay = (rawAcc % 1 === 0
            ? rawAcc.toFixed(0)
            : rawAcc.toFixed(1)
          ) + '%';
        } else {
          accDisplay = '‚Äì';
        }

        const tr = document.createElement('tr');

        // ü•á Medals for top 3
        let rankDisplay = rank;
        if (rank === 1) rankDisplay = 'ü•á';
        else if (rank === 2) rankDisplay = 'ü•à';
        else if (rank === 3) rankDisplay = 'ü•â';

        tr.innerHTML = `
          <td>${rankDisplay}</td>
          <td>${row.username}</td>
          <td>${wpmDisplay}</td>
          <td>${accDisplay}</td>
        `;

        // ‚ú® Highlight top scorer
        if (rank === 1 && sortKey !== 'rank') {
          tr.classList.add('highlight');
        }

        tbody.appendChild(tr);
      });

      tbody.classList.add('fade'); // trigger fade animation

      document.querySelectorAll('th').forEach(th => {
        th.classList.remove('sorted-asc', 'sorted-desc');
        if (th.dataset.key === sortKey) {
          th.classList.add(sortAsc ? 'sorted-asc' : 'sorted-desc');
        }
      });
    }

    function setupSorting() {
      document.querySelectorAll('th').forEach(th => {
        const key = th.dataset.key;
        if (!key) return;
        th.addEventListener('click', () => {
          if (sortKey === key) {
            sortAsc = !sortAsc;
          } else {
            sortKey = key;
            sortAsc = (key === 'wpm' || key === 'accuracy') ? false : true;
          }
          renderTable();
        });
      });
    }

    function setupModeSelector() {
      const modeSelector = document.getElementById('modeSelector');
      modeSelector.addEventListener('change', (e) => {
        selectedNumWords = Number(e.target.value);
        updateModeLabel();
        fetchData();
      });
    }

    function updateModeLabel() {
      const label = document.getElementById('modeLabel');
      label.innerText = `(${selectedNumWords} Words Leaderboard)`;
    }

    document.addEventListener('DOMContentLoaded', () => {
      setupSorting();
      setupModeSelector();
      updateModeLabel();
      fetchData();
    });
  </script>
</body>
</html>
